clear; clc;

%% --- Parâmetros físicos
params.k     = 14.9;          % W/m.K
params.rhoCp = 1.0e7;         % J/m^3.K
params.alpha = params.k/params.rhoCp;
params.qdot  = 0.0;           % fonte volumétrica (W/m^3) se quiser

%% --- Domínio
params.Lx = 0.02;             % m
params.Ly = 0.01;             % m

%% --- Malha
params.Nx  = 40;              % nós em x
params.Ny  = 10;              % nós em y

%% --- Tempo
params.tEnd = 15;             % tempo final (s)
params.CFL  = 5;            % número de Courant difusivo

%% --- Escolha do esquema numérico
%  "explicit"  -> esquema FVM totalmente explícito (θ = 0)
%  "implicit"  -> esquema totalmente implícito matricial (A\b)
%  "hybrid"    -> esquema híbrido (bordas implícitas, interior explícito)
scheme = "hybrid";   % <<< MUDA AQUI: "explicit", "implicit" ou "hybrid"

useImplicit = (scheme == "implicit");
useHybrid   = (scheme == "hybrid");

params.useImplicit = useImplicit;   % buildMesh decide dt com base nisso

switch scheme
    case "implicit"
        methodName = 'Implícito';
    case "explicit"
        methodName = 'Explícito FVM';
    case "hybrid"
        methodName = 'Híbrido';
end

%% --- Monta malha e passo de tempo
[mesh, dt, nSteps] = buildMesh(params);
mesh.dt = dt;   % importante para funções que usam dt via mesh

fprintf('dx = %.4e, dy = %.4e, dt = %.4e, nSteps = %d\n', ...
        mesh.dx, mesh.dy, dt, nSteps);

%% --- Condição inicial
T0 = 25.0;                               % °C
T  = T0*ones(mesh.Ny, mesh.Nx);          % matriz Ny x Nx

%% --- Condições de contorno (Dirichlet para comparação analítica)
T_south = 50;    % por exemplo
T_north = 75;
T_west  = 100;
T_east  = 25;

bc.left.type   = 'D';  bc.left.value   = T_west;
bc.right.type  = 'D';  bc.right.value  = T_east;
bc.bottom.type = 'D';  bc.bottom.value = T_south;
bc.top.type    = 'D';  bc.top.value    = T_north;

% Aplica BCs no tempo t = 0
T = applyBC(T, mesh, params, bc);

%% --- Solução analítica estacionária (para validação)
maxIter = 300;   % número de termos na série (ajusta se quiser)
T_ana = analyticalDirichletPlate(mesh, T_south, T_north, T_east, T_west, maxIter);

% norma da solução analítica para erro relativo
normAnaL2 = norm(T_ana(:), 2);

%% --- Monta sistema implícito (se for o caso)
if scheme == "implicit"
    sysImplicitFVM = buildImplicitSystemFVM(mesh, params, bc);
end

%% --- Coeficientes híbridos (se for o caso)
if scheme == "hybrid"
    sysHybrid = buildHybridSystemMatrix(mesh, params, bc);
end

%% --- Coeficientes explícitos FVM (se for o caso)
if scheme == "explicit"
    coeffsExp = buildExplicitFvmCoeffs(mesh, params, bc);
end

%% --- Probes e grandezas globais
ixMid = round(mesh.Nx/2);
iyMid = round(mesh.Ny/2);

% probes adicionais: próximo ao topo e à base no centro em x
iyTop    = mesh.Ny - 1;   % um nó abaixo do topo
iyBottom = 2;             % um nó acima da base

time         = (0:nSteps)' * dt;
probeCenter  = zeros(nSteps+1, 1);
probeTop     = zeros(nSteps+1, 1);
probeBottom  = zeros(nSteps+1, 1);
Tmean        = zeros(nSteps+1, 1);
errRelL2     = zeros(nSteps+1, 1);

% valores no tempo inicial (t = 0)
probeCenter(1) = T(iyMid,   ixMid);
probeTop(1)    = T(iyTop,   ixMid);
probeBottom(1) = T(iyBottom,ixMid);
Tmean(1)       = mean(T(:));
errRelL2(1)    = norm(T(:) - T_ana(:), 2) / normAnaL2;

%% --- Loop no tempo
tic;
for n = 1:nSteps

    switch scheme
        case "implicit"
            T = solveHeatStepImplicitFVM(T, sysImplicitFVM);

        case "hybrid"
            T = solveHeatStepHybridMatrix(T, sysHybrid);

        case "explicit"
            T = solveHeatStepExplicitFVM(T, coeffsExp);
    end

    % atualiza probes e grandezas globais
    probeCenter(n+1)  = T(iyMid,    ixMid);
    probeTop(n+1)     = T(iyTop,    ixMid);
    probeBottom(n+1)  = T(iyBottom, ixMid);
    Tmean(n+1)        = mean(T(:));
    errRelL2(n+1)     = norm(T(:) - T_ana(:), 2) / normAnaL2;
end
tempoExecucao = toc;
fprintf('Esquema: %s | Tempo de execução = %.4f s\n', methodName, tempoExecucao);

%% --- Erro final da simulação ---
errFinal = errRelL2(end);
fprintf('Esquema: %s | Erro relativo L2 final = %.3e\n', methodName, errFinal);


%% --- Campo de temperatura numérico (contorno 2D)
figure;
plotField(mesh, T);
title(['Campo de temperatura numérico (FVM - ' methodName ')']);

%% --- Comparação visual FVM x Analítico (contornos 2D)
[X, Y] = meshgrid(mesh.x, mesh.y);

figure;
subplot(1,2,1);
contourf(X, Y, T, 20, 'LineColor','none'); colorbar;
xlabel('x (m)'); ylabel('y (m)');
title(['Numérico (FVM - ' methodName ')']);
axis equal tight;

subplot(1,2,2);
contourf(X, Y, T_ana, 20, 'LineColor','none'); colorbar;
xlabel('x (m)'); ylabel('y (m)');
title('Analítico');
axis equal tight;

sgtitle('Comparação visual: FVM x analítico');

%% --- Evolução da temperatura no centro e em outros pontos
figure;
plot(time, probeCenter, 'k-', 'LineWidth', 1.5); hold on;
plot(time, probeTop,    'r--', 'LineWidth', 1.2);
plot(time, probeBottom, 'b-.', 'LineWidth', 1.2);
xlabel('t (s)');
ylabel('T (^{\circ}C)');
legend('Centro','Próx. topo','Próx. base','Location','best');
grid on;
title(['Evolução da temperatura em diferentes pontos - ' methodName]);

%% --- Temperatura média do domínio vs tempo
figure;
plot(time, Tmean, 'LineWidth', 1.5);
xlabel('t (s)');
ylabel('T_{média} (^{\circ}C)');
grid on;
title(['Evolução da temperatura média do domínio - ' methodName]);

%% --- Erro relativo L2 (FVM x Analítico) vs tempo
figure;
semilogy(time, errRelL2, 'LineWidth', 1.5);
xlabel('t (s)');
ylabel('Erro relativo L_2');
grid on;
title(['Convergência da solução numérica para a solução analítica - ' methodName]);

%% --- Comparação em um corte horizontal (y = meio)
iyMid = round(mesh.Ny/2);

figure;
plot(mesh.x, T_ana(iyMid,:), 'r-', 'LineWidth', 2); hold on;  % analítico = linha
plot(mesh.x, T(iyMid,:),     'ko', 'MarkerSize', 5, 'LineWidth', 1);  % FVM = pontos
xlabel('x (m)');
ylabel('T (^{\circ}C)');
legend('Analítico','FVM','Location','best');
grid on;
title(['Corte horizontal (y = L_y/2) - ' methodName]);

%% --- Comparação em um corte vertical (x = meio)
ixMid = round(mesh.Nx/2);

figure;
plot(T_ana(:,ixMid), mesh.y, 'r-', 'LineWidth', 2); hold on;   % analítico = linha
plot(T(:,ixMid),     mesh.y, 'ko', 'MarkerSize', 5, 'LineWidth', 1);  % FVM = pontos
set(gca,'YDir','normal');  % garante y crescente pra cima
xlabel('T (^{\circ}C)');
ylabel('y (m)');
legend('Analítico','FVM','Location','best');
grid on;
title(['Corte vertical (x = L_x/2) - ' methodName]);



